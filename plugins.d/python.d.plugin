
#!/usr/bin/env bash
'''':; exec "$(command -v python || command -v python3 || command -v python2 ||
echo "ERROR python IS NOT AVAILABLE IN THIS SYSTEM")" "$0" "$@" # '''

# -*- coding: utf-8 -*-
# Description:
# Author: Pawel Krupa (paulfantom)
# Author: Ilya Mashchenko (l2isbad)

import os
import sys
import threading

from re import sub
from sys import version_info, argv
from time import sleep

try:
    from collections import OrderedDict
except ImportError:
    from third_party.ordereddict import OrderedDict

try:
    from time import monotonic as time
except ImportError:
    from time import time

PY_VERSION = version_info[:2]
PLUGIN_CONFIG_DIR = os.getenv('NETDATA_CONFIG_DIR', os.path.dirname(__file__) + '/../../../../etc/netdata') + '/'
CHARTS_PY_DIR = os.path.abspath(os.getenv('NETDATA_PLUGINS_DIR', os.path.dirname(__file__)) + '/../python.d') + '/'
CHARTS_PY_CONFIG_DIR = PLUGIN_CONFIG_DIR + 'python.d/'
PYTHON_MODULES_DIR = CHARTS_PY_DIR + 'python_modules'

sys.path.append(PYTHON_MODULES_DIR)

from bases.loaders import ModuleAndConfigLoader
from bases.loggers import PythonDLogger
from bases.collection import setdefault_values, run_and_exit

BASE_CONFIG = {'update_every': os.getenv('NETDATA_UPDATE_EVERY', 1),
               'retries': 10,
               'priority': 60000,
               'autodetection_retry': 0,
               'name': str()}


MODULE_EXTENSION = '.chart.py'
OBSOLETE_MODULES = ['apache_cache', 'gunicorn_log', 'nginx_log']

JOB_INITIALIZE_MSG = 'Job initialization {status}. Module: "{module_name}", job: "{job_name}"{error}.'
JOB_CREATE_CHARTS_MSG = 'CREATE {status}. Number of charts: {number_of_charts}.'
MODULE_LOAD_MSG = 'Module load {status}. Module: "{module_name}", initialized jobs: {jobs_number}.'
UNHANDLED_EXCEPTION = 'Unhandled exception in {method_name}(). Error: {error}.'


def module_ok(m):
    return m.endswith(MODULE_EXTENSION) and m[:-len(MODULE_EXTENSION)] not in OBSOLETE_MODULES


ALL_MODULES = [m for m in sorted(os.listdir(CHARTS_PY_DIR)) if module_ok(m)]


def parse_cmd():
    debug = 'debug' in argv[1:]
    override_update_every = next((arg for arg in argv[1:] if arg.isdigit() and int(arg) > 1), False)
    modules = [''.join([m, MODULE_EXTENSION]) for m in argv[1:] if ''.join([m, MODULE_EXTENSION]) in ALL_MODULES]
    return debug, override_update_every, modules or ALL_MODULES


def multi_job_check(config):
    return next((True for key in config if isinstance(config[key], dict)), False)


class Job(object):
    def __init__(self, initialized_job, module_name, internal_name):
        """
        :param initialized_job: <Class Service>
        :param module_name: <str>
        :param internal_name: <str>
        """
        self.job = initialized_job
        self.internal_name = internal_name  # key in Modules.jobs
        self.module_name = module_name  # needed in Plugin.delete_job
        self.recheck_every = self.job.configuration.pop('autodetection_retry')
        self.checked = False  # needed in Plugin.check_job
        self.created = False  # needed in Plugin.create_job_charts
        if OVERRIDE_UPDATE_EVERY:
            self.job.update_every = int(OVERRIDE_UPDATE_EVERY)

    def __getattr__(self, item):
        return getattr(self.job, item)

    def __repr__(self):
        return self.job.__repr__()

    def is_dead(self):
        return bool(self.ident) and not self.is_alive()

    def not_launched(self):
        return not bool(self.ident)

    def is_autodetect(self):
        return self.recheck_every


class Module(object):
    def __init__(self, service, config):
        """
        :param service: <Module>
        :param config: <dict>
        """
        self.service = service
        self.name = service.__name__
        self.config = self.build_jobs_configurations(config)
        self.jobs = OrderedDict()

        self.initialize_jobs()

    def __repr__(self):
        return '<Class Module "{name}">'.format(name=self.name)

    def __iter__(self):
        return iter(OrderedDict(self.jobs).values())

    def __getitem__(self, item):
        return self.jobs[item]

    def __delitem__(self, key):
        del self.jobs[key]

    def __len__(self):
        return len(self.jobs)

    def __bool__(self):
        return bool(len(self.jobs))

    def __nonzero__(self):
        return self.__bool__()

    def build_jobs_configurations(self, config):
        """
        :param config: <dict>
        :return:
        """
        if not config:
            return {self.name: dict(BASE_CONFIG)}
        if not multi_job_check(config):
            return {self.name: setdefault_values(config, BASE_CONFIG)}
        else:
            jobs, jobs_base_config = OrderedDict(), dict()
            for attr in BASE_CONFIG:
                jobs_base_config[attr] = config.pop(attr, BASE_CONFIG[attr])
            for job_name in config:
                if not isinstance(config[job_name], dict):
                    continue

                defaulted = setdefault_values(config[job_name], base_dict=jobs_base_config)
                config[job_name]['name'] = sub(r'\s+', '_', config[job_name]['name'])
                job_name = sub(r'\s+', '_', job_name)
                job_internal_name = '_'.join([self.name, job_name])
                jobs[job_internal_name] = defaulted
            return jobs

    def initialize_jobs(self):
        for job_internal_name in self.config:
            job_name = job_internal_name[len(self.name) + 1:]
            job_override_name = self.config[job_internal_name].pop('name')
            self.config[job_internal_name]['module_name'] = self.name
            self.config[job_internal_name]['job_name'] = job_name
            self.config[job_internal_name]['override_name'] = job_override_name
            try:
                initialized_job = self.service.Service(configuration=self.config[job_internal_name])
            except Exception as error:
                Logger.error(JOB_INITIALIZE_MSG.format(status='FAILED',
                                                       module_name=self.name,
                                                       job_name=job_name,
                                                       error=', error: {0}'.format(error)))
                continue
            else:
                Logger.debug(JOB_INITIALIZE_MSG.format(status='SUCCESS',
                                                       module_name=self.name,
                                                       job_name=job_name,
                                                       error=''))
                self.jobs[job_internal_name] = Job(initialized_job=initialized_job,
                                                   module_name=self.name,
                                                   internal_name=job_internal_name)
        del self.config
        del self.service


class Plugin(object):
    def __init__(self):
        self.loader = ModuleAndConfigLoader()
        self.modules = OrderedDict()
        self.sleep_time = 1
        self.number_of_runs = 0
        self.config, error = self.loader.load_config_from_file(PLUGIN_CONFIG_DIR + 'python.d.conf')
        if error:
            run_and_exit(Logger.error)(error)

        if not self.config.get('enabled', True):
            run_and_exit(Logger.info)('DISABLED in configuration file.')

        self.load_and_initialize_modules()
        if not self.modules:
            run_and_exit(Logger.info)('No modules to run. Exit...')

    def __iter__(self):
        return iter(dict(self.modules).values())

    @property
    def jobs(self):
        return (job for mod in self for job in mod)

    @property
    def dead_jobs(self):
        return (job for job in self.jobs if job.is_dead())

    @property
    def autodetect_jobs(self):
        return [job for job in self.jobs if job.not_launched()]

    def enabled_modules(self):
        for mod in MODULES_TO_RUN:
            mod_name = mod[:-len(MODULE_EXTENSION)]
            mod_path = CHARTS_PY_DIR + mod
            conf_path = ''.join([CHARTS_PY_CONFIG_DIR, mod_name, '.conf'])

            if DEBUG:
                yield mod, mod_name, mod_path, conf_path
            else:
                if all([self.config.get('default_run', True),
                        self.config.get(mod_name, True)]):
                    yield mod, mod_name, mod_path, conf_path

                elif all([not self.config.get('default_run'),
                          self.config.get(mod_name)]):
                    yield mod, mod_name, mod_path, conf_path

    def load_and_initialize_modules(self):
        for mod, mod_name, mod_path, conf_path in self.enabled_modules():
            loaded_module, error = self.loader.load_module_from_file(mod_name, mod_path)
            if error:
                Logger.error('Module load failed. Module: {name}, error: {error}.'.format(name=mod,
                                                                                          error=error))
                continue
            loaded_config, error = self.loader.load_config_from_file(conf_path)
            if error:
                Logger.error('Config load failed. Module {module}, error: {error}.'.format(module=mod_name,
                                                                                           error=error))
            initialized_module = Module(service=loaded_module, config=loaded_config)
            Logger.debug(MODULE_LOAD_MSG.format(status='OK' if initialized_module else 'FAILED',
                                                module_name=initialized_module.name,
                                                jobs_number=len(initialized_module)))
            if initialized_module:
                self.modules[initialized_module.name] = initialized_module

    @staticmethod
    def check_job(job):
        """
        :param job: <Job>
        :return:
        """
        try:
            check_ok = job.check()
        except Exception as error:
            job.error(UNHANDLED_EXCEPTION.format(method_name='check',
                                                 error=error))
            return False
        else:
            log = job.info if check_ok else job.error
            log('CHECK {status}'.format(status='OK' if check_ok else 'FAILED'))
            if job.is_autodetect():
                if not check_ok:
                    job.error('Next CHECK in {0} seconds.'.format(job.recheck_every))
            return check_ok

    @staticmethod
    def create_job_charts(job):
        """
        :param job: <Job>
        :return:
        """
        try:
            create_ok = job.create()
        except Exception as error:
            job.error(UNHANDLED_EXCEPTION.format(method_name='create',
                                                 error=error))
            return False
        else:
            job.debug(JOB_CREATE_CHARTS_MSG.format(status='OK' if create_ok else 'FAILED',
                                                   number_of_charts=len(job.charts)))
            return create_ok

    def delete_job(self, job):
        """
        :param job: <Job>
        :return:
        """
        del self.modules[job.module_name][job.internal_name]

    def run_check(self):
        checked = list()
        for job in self.jobs:
            if job.name in checked:
                Logger.info('DROPPED: {job_name}. Already served by another job.'.format(job_name=job.internal_name))
                self.delete_job(job)
                continue
            ok = self.check_job(job)
            if ok:
                checked.append(job.name)
                job.checked = True
                continue
            if not job.is_autodetect():
                self.delete_job(job)

    def run_create(self):
        for job in self.jobs:
            if not job.checked:
                continue
            ok = self.create_job_charts(job)
            if ok:
                job.created = True
                continue
            self.delete_job(job)

    def start(self):
        self.run_check()
        self.run_create()
        for job in self.jobs:
            if job.created:
                job.start()

        while True:
            if threading.active_count() <= 1 and not self.autodetect_jobs:
                run_and_exit(Logger.info)('FINISHED')

            sleep(self.sleep_time)
            self.cleanup()
            self.autodetect_retry()

    def cleanup(self):
        for job in self.dead_jobs:
            self.delete_job(job)
        for mod in self:
            if not mod:
                del self.modules[mod.name]

    def autodetect_retry(self):
        self.number_of_runs += self.sleep_time
        for job in self.autodetect_jobs:
            if self.number_of_runs % job.recheck_every == 0:
                checked = self.check_job(job)
                if checked:
                    created = self.create_job_charts(job)
                    if not created:
                        self.delete_job(job)
                        continue
                    job.start()


if __name__ == '__main__':
    DEBUG, OVERRIDE_UPDATE_EVERY, MODULES_TO_RUN = parse_cmd()
    Logger = PythonDLogger()
    if DEBUG:
        Logger.logger.severity = 'DEBUG'
    Logger.info('Using python {version}'.format(version=PY_VERSION[0]))

    plugin = Plugin()
    plugin.start()
