#!/usr/bin/env python3

import os
import sys
import time
import json
try:
    assert sys.version_info >= (3,1)
    import importlib.machinery
except AssertionError:
    sys.stderr.write('Not supported python version. Needed python >= 3.1\n')
    sys.stdout.write('DISABLE\n')
    sys.exit(1)


class PythonCharts(object):
    
    def __init__(self,
                 interval=None,
                 modules=[],
                 modules_path='../python.d/',
                 modules_configs='../conf.d/',
                 modules_disabled=[]):
        self.first_run = True
        # set configuration directory
        self.configs = modules_configs

        # load modules
        modules = self._load_modules(modules_path,modules)
        
        # check if loaded modules are on disabled modules list
        self.modules = [ m for m in modules if m.__name__ not in modules_disabled ]
        
        # load configuration files
        self._load_configs()

        # good economy and prosperity:
        self.jobs = self._create_jobs(self.modules)


    def _create_jobs(self,modules):
    # module store a definition of Service class
    # module store configuration in module.config
    # configs are list of dicts or a dict
    # one dict is one service
    # iterate over list of modules and inside one loop iterate over configs
        jobs = []
        for module in modules:
            if type(module.config) is dict:
                jobs.append(self._job(module,module.config))
            elif type(module.config) is list:
                for conf in module.config:
                    jobs.append(self._job(module,conf))
        
        return [j for j in jobs if j is not None]


    def _job(self,module,conf):
    # register a new job
        # default job settings:
        settings = {'update_every' : 11,
                    'priority'     : 12345,
                    'retries'      : 0}
        # ensure job has basic variables
        # first check in job config
        # next check in module
        # at last assign defaults
        for key in settings:
            try:
                settings[key] = int(conf[key])
            except (KeyError,ValueError):
                try:
                    settings[key] = int(getattr(module, key))
                except (AttributeError,ValueError):
                    pass

        try:
            job = module.Service(configuration=conf)
        except Exception as e:
            sys.stderr.write(module.__name__ +
                             ": Couldn't start one of jobs " +
                             str(e))
            return None
        else:
            # set execution_name (needed to plot run time graphs)
            try:
                job.execution_name = module.__name__ + \
                                     "_" + \
                                     str(conf['name'])
            except KeyError:
                job.execution_name = module.__name__

    def _import_module(self, path, name=None):
    # try to import module using only its path
        if name is None:
            name = path.split('/')[-1]
            if name[-9:] != ".chart.py":
                return None
            name = name[:-9]
        try:
            return importlib.machinery.SourceFileLoader(name, path).load_module()
        except Exception as e:
            debug(str(e))
            return None

    def _load_modules(self, path, modules):
        # check if plugin directory exists
        if not os.path.isdir(path):
            debug("cannot find charts directory ", path)
            sys.stdout.write("DISABLE\n")
            sys.exit(1)

        # load modules
        loaded = []
        if len(modules) > 0:
            for m in modules:
                mod = self._import_module(path + m + ".chart.py")
                if mod is not None:
                    loaded.append(mod)
        else:
            # scan directory specified in path and load all modules from there
            names = os.listdir(path)
            for mod in names:
                m = self._import_module(path + mod)
                if m is not None:
                    debug("loading chart: '" + path + mod + "'")
                    loaded.append(m)
        return loaded

    def _load_configs(self):
    # function modifies every loaded module in self.modules
        for m in self.modules:
            configfile = self.configs + m.__name__ + ".conf"
            if os.path.isfile(configfile):
                debug("loading chart options: '" + configfile + "'")
                for k, v in read_config(configfile).items():
                    try:
                        setattr(m, k, v)
                    except AttributeError:
                        self._disable_module(m,"misbehaving having bad configuration")
            else:
                debug(m.__name__ +
                      ": configuration file '" +
                      configfile +
                      "' not found. Using defaults.")

    def _stop(self, job, reason=None): #FIXME test if Service has __name__
    # modifies self.jobs
        self.jobs.remove(job)
        if reason is None:
            return
        elif reason[:3] == "no ":
            debug("chart '" +
                  job.__name__,
                  "' does not seem to have " +
                  reason[3:] +
                  "() function. Disabling it.")
        elif reason[:7] == "failed ":
            debug("chart '" +
                  job.__name__ + "' " +
                  reason[7:] +
                  "() function reports failure.")
        elif reason[:13] == "configuration":
            debug(job.__name__,
                  "configuration file '" +
                  self.configs +
                  job.__name__ +
                  ".conf' not found. Using defaults.")
        elif reason[:11] == "misbehaving":
            debug(job.__name__, "is "+reason)

    def check(self):
    # try to execute check() on every job
        for job in self.jobs:
            try:
                if not job.check():
                    self._stop(job, "failed check")
            except AttributeError:
                self._stop(job, "no check")
            except (UnboundLocalError, Exception) as e:
                self._stop(job, "misbehaving. Reason: " + str(e))

    def create(self):
    # try to execute create() on every job
        for job in self.jobs:
            try:
                if not job.create():
                    self._stop(job, "failed create")
                else:
                    chart = job.execution_name
                    sys.stdout.write(
                        "CHART netdata.plugin_pythond_" +
                        chart +
                        " '' 'Execution time for " +
                        chart +
                        " plugin' 'milliseconds / run' python.d netdata.plugin_python area 145000 " +
                        str(job.timetable['freq']) +
                        '\n')
                    sys.stdout.write("DIMENSION run_time 'run time' absolute 1 1\n\n")
                    sys.stdout.flush()
            except AttributeError:
                self._stop(job, "no create")
            except (UnboundLocalError, Exception) as e:
                self._stop(job, "misbehaving. Reason: " + str(e))

    def _update_job(self, job):
    # try to execute update() on every job and draw run time graph 
        t_start = time.time()
        # check if it is time to execute job update() function
        if job.timetable['next'] > t_start:
            return
        try:
            if self.first_run:
                since_last = 0
            else:
                since_last = int((t_start - job.timetable['last']) * 1000000)
            if not job.update(since_last):
                self._stop(job, "update failed")
                return
        except AttributeError:
            self._stop(job, "no update")
            return
        except (UnboundLocalError, Exception) as e:
            self._stop(job, "misbehaving. Reason: " + str(e))
            return
        t_end = time.time()
        job.timetable['next'] = t_end - (t_end % job.timetable['freq']) + job.timetable['freq']
        # draw performance graph
        if self.first_run:
            dt = 0
        else:
            dt = int((t_end - job.timetable['last']) * 1000000)
        sys.stdout.write("BEGIN netdata.plugin_pythond_"+job.execution_name+" "+str(since_last)+'\n')
        sys.stdout.write("SET run_time = " + str(int((t_end - t_start) * 1000)) + '\n')
        sys.stdout.write("END\n")
        sys.stdout.flush()
        job.timetable['last'] = t_start
        self.first_run = False

    def update(self):
    # run updates (this will stay forever and ever and ever forever and ever it'll be the one...)
        self.first_run = True
        while True:
            t_begin = time.time()
            next_runs = []
            for job in self.jobs:
                self._update_job(job)
                try:
                    next_runs.append(job.timetable['next'])
                except KeyError:
                    pass
            if len(next_runs) == 0:
                debug("No plugins loaded")
                sys.stdout.write("DISABLE\n")
                sys.exit(1)
            time.sleep(min(next_runs) - time.time())


def read_config(path):
    # FIXME move to JSON configurations
#    try:
#        with open(path, 'r') as f:
#            config_str = '[config]\n' + f.read()
#    except IsADirectoryError:
#        debug(str(path), "is a directory")
#        return
#    try:
#        debug("Malformed configuration file: "+str(e))
#        return
    return None


def debug(*args):
    if not DEBUG_FLAG:
        return
    sys.stderr.write(PROGRAM + ":")
    for i in args:
        sys.stderr.write(" " + str(i))
    sys.stderr.write("\n")
    sys.stderr.flush()


def parse_cmdline(directory, *commands):
    # TODO number -> interval
    global DEBUG_FLAG
    DEBUG_FLAG = False
    interval = None

    mods = []
    for cmd in commands[1:]:
        if cmd == "check":
            pass
        elif cmd == "debug" or cmd == "all":
            DEBUG_FLAG = True
            # redirect stderr to stdout?
        elif os.path.isfile(directory + cmd + ".chart.py") or os.path.isfile(directory + cmd):
            DEBUG_FLAG = True
            mods.append(cmd.replace(".chart.py", ""))
        else:
            try:
                interval = int(cmd)
            except ValueError:
                pass

    debug("started from", commands[0], "with options:", *commands[1:])
    if len(mods) == 0 and DEBUG_FLAG is False:
        interval = None

    return {'interval': interval,
            'modules': mods}


# if __name__ == '__main__':
def run():
    global DEBUG_FLAG, PROGRAM
    DEBUG_FLAG = True
    PROGRAM = sys.argv[0].split('/')[-1].split('.plugin')[0]
    # parse env variables
    # https://github.com/firehol/netdata/wiki/External-Plugins#environment-variables
    main_dir = os.getenv('NETDATA_PLUGINS_DIR',
                         os.path.abspath(__file__).strip("python.d.plugin.py"))
    config_dir = os.getenv('NETDATA_CONFIG_DIR', "/etc/netdata/")
    interval = os.getenv('NETDATA_UPDATE_EVERY', None)

    # read configuration file
    disabled = []
    if config_dir[-1] != '/':
        config_dir += '/'
    configfile = config_dir + "python.d.conf"

    try:
        conf = read_config(configfile)
        try:
            if str(conf['enable']) == "no":
                debug("disabled in configuration file")
                sys.stdout.write("DISABLE\n")
                sys.exit(1)
        except (KeyError, TypeError):
            pass
        try:
            modules_conf = conf['plugins_config_dir']
        except (KeyError):
            modules_conf = config_dir + "python.d/"  # default configuration directory
        try:
            modules_dir = conf['plugins_dir']
        except (KeyError):
            modules_dir = main_dir.replace("plugins.d", "python.d")
        try:
            interval = int(conf['interval'])
        except (KeyError, TypeError):
            pass  # use default interval from NETDATA_UPDATE_EVERY
        try:
            DEBUG_FLAG = bool(conf['debug'])
        except (KeyError, TypeError):
            pass
        for k, v in conf.items():
            if k in ("plugins_config_dir", "plugins_dir", "interval", "debug"):
                continue
            if v == 'no':
                disabled.append(k)
    except FileNotFoundError:
        modules_conf = config_dir
        modules_dir = main_dir.replace("plugins.d", "python.d")

    # directories should end with '/'
    if modules_dir[-1] != '/':
        modules_dir += "/"
    if modules_conf[-1] != '/':
        modules_conf += "/"

    # parse passed command line arguments
    out = parse_cmdline(modules_dir, *sys.argv)
    modules = out['modules']
    if out['interval'] is not None:
        interval = out['interval']
    
    # configure environement to run modules
    sys.path.append(modules_dir+"python_modules") # append path to directory with modules dependencies
    
    # run plugins
    charts = PythonCharts(interval, modules, modules_dir, modules_conf, disabled)
    charts.check()
    charts.create()
    charts.update()

if __name__ == '__main__':
    run()
